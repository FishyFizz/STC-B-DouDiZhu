C51 COMPILER V9.05   EVENTS                                                                06/28/2022 11:57:17 PAGE 1   


C51 COMPILER V9.05, COMPILATION OF MODULE EVENTS
OBJECT MODULE PLACED IN .\Objects\events.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Src\events\events.c LARGE OMF2 OPTIMIZE(0,SPEED) BROWSE NOAREGS DEFINE(STC)
                    - DEBUG PRINT(.\Listings\events.lst) OBJECT(.\Objects\events.obj)

line level    source

   1          #include "events.h"
   2          #include "../button/button.h"
   3          #include "../bit_ops/bit_ops.h"
   4          #include "../rs485/rs485.h"
   5          
   6          XDATA u32 curr_events = 0;
   7          
   8          XDATA u8 proc_waiting_evt = 0;
   9          XDATA u32 proc_listening_list[8] = {0,0,0,0,0,0,0,0};
  10          /*
  11              Example: process P waiting on event EVT_XXX and EVT_YYY
  12              proc_waiting_evt.bit[P] = 1;
  13              proc_listening_list[P] = EVT_XXX | EVT_YYY;
  14          */
  15          
  16          void dispatch_events(u8 pid)
  17          {
  18   1          if(proc_waiting_evt & BIT(pid))
  19   1          {
  20   2              if(proc_listening_list[pid] & curr_events)
  21   2              {
  22   3                  /*
  23   3                  process can read this to know which of 
  24   3                  the listened events is actually occured.
  25   3                  */
  26   3                  proc_listening_list[pid] = curr_events; 
  27   3                  CLEARBIT(proc_waiting_evt, pid);
  28   3              }
  29   2          }
  30   1      }
  31          
  32          void collect_btnevts()
  33          {
  34   1          update_button_state();
  35   1      
  36   1          if(btnstate_posedge & BTNSTATE_B1) curr_events |= EVT_BTN1_DN;
  37   1          if(btnstate_posedge & BTNSTATE_B2) curr_events |= EVT_BTN2_DN;
  38   1          if(btnstate_posedge & BTNSTATE_B3) curr_events |= EVT_BTN3_DN;
  39   1          if(btnstate_posedge & BTNSTATE_UP)      curr_events |= EVT_NAV_U;
  40   1          if(btnstate_posedge & BTNSTATE_DOWN)    curr_events |= EVT_NAV_D;
  41   1          if(btnstate_posedge & BTNSTATE_LEFT)    curr_events |= EVT_NAV_L;
  42   1          if(btnstate_posedge & BTNSTATE_RIGHT)   curr_events |= EVT_NAV_R;
  43   1          if(btnstate_posedge & BTNSTATE_PUSH)    curr_events |= EVT_NAV_PUSH;
  44   1          
  45   1          if(btnstate_negedge & BTNSTATE_B1) curr_events |= EVT_BTN1_UP;
  46   1          if(btnstate_negedge & BTNSTATE_B2) curr_events |= EVT_BTN2_UP;
  47   1          if(btnstate_negedge & BTNSTATE_B3) curr_events |= EVT_NAV_BTN3_RESET;
  48   1          if(btnstate_negedge & BTNSTATE_UP)      curr_events |= EVT_NAV_BTN3_RESET;
  49   1          if(btnstate_negedge & BTNSTATE_DOWN)    curr_events |= EVT_NAV_BTN3_RESET;
  50   1          if(btnstate_negedge & BTNSTATE_LEFT)    curr_events |= EVT_NAV_BTN3_RESET;
  51   1          if(btnstate_negedge & BTNSTATE_RIGHT)   curr_events |= EVT_NAV_BTN3_RESET;
  52   1          if(btnstate_negedge & BTNSTATE_PUSH)    curr_events |= EVT_NAV_BTN3_RESET;
  53   1      }
  54          
C51 COMPILER V9.05   EVENTS                                                                06/28/2022 11:57:17 PAGE 2   

  55          void collect_uartevts()
  56          {
  57   1          if(rs485_evtstate)
  58   1          {
  59   2              rs485_evtstate = 0;
  60   2              curr_events |= EVT_UART2_RECV;
  61   2          }
  62   1      }
  63          
  64          void process_events()
  65          {
  66   1          curr_events = 0;
  67   1          
  68   1          collect_btnevts();
  69   1          collect_uartevts();
  70   1      
  71   1          dispatch_events(0);
  72   1          dispatch_events(1);
  73   1          dispatch_events(2);
  74   1          dispatch_events(3);
  75   1          dispatch_events(4);
  76   1          dispatch_events(5);
  77   1          dispatch_events(6);
  78   1          dispatch_events(7);
  79   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1001    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     38    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
